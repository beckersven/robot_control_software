%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Explanation}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}



\title{CoppeliaSim Interface Documentation}
\date{Feb 11, 2021}
\release{1.0}
\author{Sven Becker}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}

\begin{quote}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Coppeliasim_interface_overview_simple}.png}
\caption{\sphinxfootnotemark[1]}\label{\detokenize{index:id3}}\end{figure}
%
\begin{footnotetext}[1]\sphinxAtStartFootnote
\sphinxhref{https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/Ros\_logo.svg/1280px-Ros\_logo.svg.png}{Source}
%
\end{footnotetext}\ignorespaces 

\chapter{Overview}
\label{\detokenize{Overview:overview}}\label{\detokenize{Overview::doc}}\label{\detokenize{Overview:coppeliasim-interface-s-documentation}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{Coppeliasim_interface_overview}.png}
\end{figure}

\sphinxstylestrong{This package is the nexus between ROS and CoppeliaSim.} The {\hyperref[\detokenize{SimulationSynchronizer:simulation-synchronizer}]{\sphinxcrossref{\DUrole{std,std-ref}{SimulationSynchronizer C++-class}}}} ensures that the time in ROS (available through ‘/clock’-topic) increases with the same rate as in CoppeliaSim.
This is crucial for hard-timed tasks, like simulated real-time-control. This module also calls specified services at each simulation-step to for example read-out the Laser-Scanner or perform one control-cycle.
For the latter, {\hyperref[\detokenize{HardwareInterface:hardware-interface}]{\sphinxcrossref{\DUrole{std,std-ref}{HardwareInterface C++-class}}}} mimics a real ros\_control-interface but instead of controlling actual motors, the controller output is forwarded to the joints in CoppeliaSim’s UR10e and
the simulated joint-values are used as feedback for the ROS-controllers. This package was designed similarly to the drivers of the real UR-robots, which means that it works
on the one hand seemlessly with every framework developed for real robots (like MoveIt) and on the other hand that movements evaluated in a simulation
can be identically performed in reality when the real driver is loaded instead - \sphinxstyleemphasis{No remapping of ROS-topics, etc. is required}!
The third component, {\hyperref[\detokenize{point_cloud_manager:point-cloud-manager}]{\sphinxcrossref{\DUrole{std,std-ref}{point\_cloud\_manager Python-module}}}} , makes the Point-Cloud measured by the scanner in CoppeliaSim accessible to the ROS-system by transforming it. It also performs
stitching of the measured Point-Cloud as well the application of an uncertainty-model to immediately review the measurement.


\chapter{HardwareInterface C++-class}
\label{\detokenize{HardwareInterface:hardware-interface}}\label{\detokenize{HardwareInterface::doc}}\label{\detokenize{HardwareInterface:hardwareinterface-c-class}}\index{coppeliasim\_interface::HardwareInterface (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterfaceE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface}}\sphinxbfcode{class }%
\pysigstopmultiline
Hardware-Interface for the UR10e-model in CoppeliaSim that behaves just like the driver for the real robot. 
\paragraph{Public Functions}
\index{coppeliasim\_interface::HardwareInterface::HardwareInterface (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterface17HardwareInterfaceEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1a731c52969b54a2cdda78a494bcd878ee}}\pysiglinewithargsret{\sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{HardwareInterface}}{}{}%
\pysigstopmultiline
Construct a new Hardware Interface object and initialize all class members that do not require a ROS- or CoppeliaSim-connection. 

\end{fulllineitems}

\index{coppeliasim\_interface::HardwareInterface::\textasciitilde{}HardwareInterface (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterfaceD0Ev}}%
\pysigstartmultiline
virtual \phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1a61047459c300ddd92e0b2d82e3b7c2e2}}\pysiglinewithargsret{\sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{\textasciitilde{}HardwareInterface}}{}{}%
\pysigstopmultiline
Destroy the Hardware Interface object and handle disconnection from CoppeliaSim. 

\end{fulllineitems}

\index{coppeliasim\_interface::HardwareInterface::init (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterface4initERN3ros10NodeHandleERN3ros10NodeHandleE}}%
\pysigstartmultiline
virtual \phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1ada54343beeb383c43951877e3d49cf8e}}\pysiglinewithargsret{bool \sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{init}}{ros::NodeHandle \&\sphinxstyleemphasis{root\_nh}, ros::NodeHandle \&\sphinxstyleemphasis{robot\_nh}}{}%
\pysigstopmultiline
Connects program to CoppeliaSim and obtains the required handles. Reads in the required ROS-parameters and initializes all interfaces that are implemented in the real hardware-interface. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode

Whether connection to CoppeliaSim was successful and the hardware-interfaces could be set-up work with CoppeliaSim-Joints 


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} \sphinxcode{root\_nh} - 
ROS-nodehandle for operations at root-level (names starting with ‘/…’) 

\item {} \sphinxcode{robot\_nh} - 
ROS-nodehandle for operations in the hardware-interface-nodes namespace 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{coppeliasim\_interface::HardwareInterface::read (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterface4readERKN3ros4TimeERKN3ros8DurationE}}%
\pysigstartmultiline
virtual \phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1abc05d9a9e8761462b2161a33f55203cc}}\pysiglinewithargsret{void \sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{read}}{\sphinxbfcode{const} ros::Time \&\sphinxstyleemphasis{time}, \sphinxbfcode{const} ros::Duration \&\sphinxstyleemphasis{period}}{}%
\pysigstopmultiline
Gets the joint-data (position, velocity, torque) from CoppeliaSim in a blocking way. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} \sphinxcode{time} - 
Required by ROS-HardwareInterface specification (fullfills nothing here) 

\item {} \sphinxcode{period} - 
Required by ROS-HardwareInterface (fullfills nothing here) 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{coppeliasim\_interface::HardwareInterface::write (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterface5writeERKN3ros4TimeERKN3ros8DurationE}}%
\pysigstartmultiline
virtual \phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1a2a116645fc33233e4b9b1a37a9165674}}\pysiglinewithargsret{void \sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{write}}{\sphinxbfcode{const} ros::Time \&\sphinxstyleemphasis{time}, \sphinxbfcode{const} ros::Duration \&\sphinxstyleemphasis{period}}{}%
\pysigstopmultiline
Set the joint-target-values (velocities or positions, depending on active controller) in CoppeliaSim in a blocking way. 

\end{fulllineitems}

\index{coppeliasim\_interface::HardwareInterface::prepareSwitch (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterface13prepareSwitchERKNSt4listIN18hardware_interface14ControllerInfoEEERKNSt4listIN18hardware_interface14ControllerInfoEEE}}%
\pysigstartmultiline
virtual \phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1a5b7c2e8dcf2fa17ba6bde7ea001d59e3}}\pysiglinewithargsret{bool \sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{prepareSwitch}}{\sphinxbfcode{const} std::list\textless{}hardware\_interface::ControllerInfo\textgreater{} \&\sphinxstyleemphasis{start\_list}, \sphinxbfcode{const} std::list\textless{}hardware\_interface::ControllerInfo\textgreater{} \&\sphinxstyleemphasis{stop\_list}}{}%
\pysigstopmultiline
\end{fulllineitems}

\index{coppeliasim\_interface::HardwareInterface::doSwitch (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterface8doSwitchERKNSt4listIN18hardware_interface14ControllerInfoEEERKNSt4listIN18hardware_interface14ControllerInfoEEE}}%
\pysigstartmultiline
virtual \phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1aae36a63c5125172387cfcbf21f9a1c24}}\pysiglinewithargsret{void \sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{doSwitch}}{\sphinxbfcode{const} std::list\textless{}hardware\_interface::ControllerInfo\textgreater{} \&\sphinxstyleemphasis{start\_list}, \sphinxbfcode{const} std::list\textless{}hardware\_interface::ControllerInfo\textgreater{} \&\sphinxstyleemphasis{stop\_list}}{}%
\pysigstopmultiline
Tries to turn on or off provided controllers. The provided controllers must be applicable with this {\hyperref[\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface}]{\sphinxcrossref{\DUrole{std,std-ref}{HardwareInterface}}}}, otherwise they do not trigger any changes. 

\begin{description}
\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} \sphinxcode{start\_list} - 
Controllers to start 

\item {} \sphinxcode{stop\_list} - 
Controllers to stop 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{coppeliasim\_interface::HardwareInterface::zeroFTSensor (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterface12zeroFTSensorERN8std_srvs14TriggerRequestERN8std_srvs15TriggerResponseE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1af3204245bbf1e9e317d5d0a57b3c86c2}}\pysiglinewithargsret{bool \sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{zeroFTSensor}}{std\_srvs::TriggerRequest \&\sphinxstyleemphasis{req}, std\_srvs::TriggerResponse \&\sphinxstyleemphasis{res}}{}%
\pysigstopmultiline
Should normally tare the force-torque-sensor but is not implemented for performance reasons (service response gets delivered, but is always ‘success == false’) 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode

always ‘true’ 


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} \sphinxcode{req} - 
(contains no information) 

\item {} \sphinxcode{res} - 
Trigger-Response (currently always ‘success=false’ with a corresponding message as this is not implemented) 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{coppeliasim\_interface::HardwareInterface::setSpeedSlider (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterface14setSpeedSliderERN7ur_msgs29SetSpeedSliderFractionRequestERN7ur_msgs30SetSpeedSliderFractionResponseE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1a0fb3b4bf382fc390db4d8c40036a683b}}\pysiglinewithargsret{bool \sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{setSpeedSlider}}{ur\_msgs::SetSpeedSliderFractionRequest \&\sphinxstyleemphasis{req}, ur\_msgs::SetSpeedSliderFractionResponse \&\sphinxstyleemphasis{res}}{}%
\pysigstopmultiline
Sets the speed-scaling as requested. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode

always ‘true’ 


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} \sphinxcode{req} - 
Request with target value of the speed slider 

\item {} \sphinxcode{res} - 
Response with information about whether the speed slider could be set (i.e. target lies in the interval {[}0.01,1{]}) 

\end{itemize}

\end{description}


\end{fulllineitems}

\index{coppeliasim\_interface::HardwareInterface::setPause (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{HardwareInterface:_CPPv2N21coppeliasim_interface17HardwareInterface8setPauseERN8std_srvs14SetBoolRequestERN8std_srvs15SetBoolResponseE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{HardwareInterface:project0classcoppeliasim__interface_1_1HardwareInterface_1a00cc87162beaecdf82c1510ae84b2d95}}\pysiglinewithargsret{bool \sphinxcode{coppeliasim\_interface::HardwareInterface::}\sphinxbfcode{setPause}}{std\_srvs::SetBoolRequest \&\sphinxstyleemphasis{req}, std\_srvs::SetBoolResponse \&\sphinxstyleemphasis{res}}{}%
\pysigstopmultiline
Controls if the robots running state (RUNNING = normal, PAUSED = halted, RAMPUP = Accelerating from PAUSED to RUNNING) 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode

always ‘true’ 


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} \sphinxcode{req} - 
Contains boolean flag about which run-state should be entered 

\item {} \sphinxcode{res} - 
If the desired state could be set (false, if in RAMPUP or if the desired state is already set) with an descriptive message 

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}



\chapter{point\_cloud\_manager Python-module}
\label{\detokenize{point_cloud_manager:point-cloud-manager-python-module}}\label{\detokenize{point_cloud_manager::doc}}\label{\detokenize{point_cloud_manager:point-cloud-manager}}

\chapter{SimulationSynchronizer C++-class}
\label{\detokenize{SimulationSynchronizer:simulationsynchronizer-c-class}}\label{\detokenize{SimulationSynchronizer:simulation-synchronizer}}\label{\detokenize{SimulationSynchronizer::doc}}\index{coppeliasim\_interface::SimulationSynchronizer (C++ class)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SimulationSynchronizer:_CPPv2N21coppeliasim_interface22SimulationSynchronizerE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{SimulationSynchronizer:project0classcoppeliasim__interface_1_1SimulationSynchronizer}}\sphinxbfcode{class }%
\pysigstopmultiline
Synchronizes the ROS-time with the CoppeliaSim-time in the sense, that both ‘clocks’ are running at the same speed (but not necessarely at the same time), and ensures that time-critical tasks in the ROS-domain are performed in sync with each simulation-step. 
\paragraph{Public Functions}
\index{coppeliasim\_interface::SimulationSynchronizer::SimulationSynchronizer (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SimulationSynchronizer:_CPPv2N21coppeliasim_interface22SimulationSynchronizer22SimulationSynchronizerEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{SimulationSynchronizer:project0classcoppeliasim__interface_1_1SimulationSynchronizer_1ac18bb936436db0207cb883539542667b}}\pysiglinewithargsret{\sphinxcode{coppeliasim\_interface::SimulationSynchronizer::}\sphinxbfcode{SimulationSynchronizer}}{}{}%
\pysigstopmultiline
Construct a new Simulation Synchronizer object and initialize all members that do not necessarely need a ROS- or CoppeliaSim-connection. 

\end{fulllineitems}

\index{coppeliasim\_interface::SimulationSynchronizer::\textasciitilde{}SimulationSynchronizer (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SimulationSynchronizer:_CPPv2N21coppeliasim_interface22SimulationSynchronizerD0Ev}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{SimulationSynchronizer:project0classcoppeliasim__interface_1_1SimulationSynchronizer_1afc14256edba11b6ef38de06292476f10}}\pysiglinewithargsret{\sphinxcode{coppeliasim\_interface::SimulationSynchronizer::}\sphinxbfcode{\textasciitilde{}SimulationSynchronizer}}{}{}%
\pysigstopmultiline
Destroy the Simulation Synchronizer object and stop the CoppeliaSim-Simulation and close the connection to CoppeliaSim. 

\end{fulllineitems}

\index{coppeliasim\_interface::SimulationSynchronizer::advanceSimulation (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SimulationSynchronizer:_CPPv2N21coppeliasim_interface22SimulationSynchronizer17advanceSimulationEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{SimulationSynchronizer:project0classcoppeliasim__interface_1_1SimulationSynchronizer_1a511f8bf3569c7dce3dafb2a6f30dd6f2}}\pysiglinewithargsret{bool \sphinxcode{coppeliasim\_interface::SimulationSynchronizer::}\sphinxbfcode{advanceSimulation}}{}{}%
\pysigstopmultiline
Advances the simulation in CoppeliaSim exactly one time-step (dt = ‘sim-dt’). Blocks until CoppeliaSim has finished the calculations for this advancement. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode

Whether advancement was successful (could trigger calculations in CoppeliaSim and received success-feedback) 


\end{description}


\end{fulllineitems}

\index{coppeliasim\_interface::SimulationSynchronizer::synchronizeROS (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SimulationSynchronizer:_CPPv2N21coppeliasim_interface22SimulationSynchronizer14synchronizeROSEv}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{SimulationSynchronizer:project0classcoppeliasim__interface_1_1SimulationSynchronizer_1a14e5777b6eacdd0a2d95603bad137ea0}}\pysiglinewithargsret{bool \sphinxcode{coppeliasim\_interface::SimulationSynchronizer::}\sphinxbfcode{synchronizeROS}}{}{}%
\pysigstopmultiline
Increases ROS-time with the same dt as CoppeliaSim’s ‘sim-dt’ and calls all ROS-services that should be handled during one time-step afterwards. 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode

Whether all Services were called successfully 


\end{description}


\end{fulllineitems}

\index{coppeliasim\_interface::SimulationSynchronizer::init (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SimulationSynchronizer:_CPPv2N21coppeliasim_interface22SimulationSynchronizer4initERN3ros10NodeHandleE}}%
\pysigstartmultiline
\phantomsection\label{\detokenize{SimulationSynchronizer:project0classcoppeliasim__interface_1_1SimulationSynchronizer_1a86f3212df7425b946c6148ab324fd2bc}}\pysiglinewithargsret{bool \sphinxcode{coppeliasim\_interface::SimulationSynchronizer::}\sphinxbfcode{init}}{ros::NodeHandle \&\sphinxstyleemphasis{nh}}{}%
\pysigstopmultiline
Connects instance to CoppeliaSim (registers it as client for the remoteApi and starts simulation in synchroneous mode) and ROS (preparing /clock-publication and registering Services that should be handled every simulation-step) 

\begin{description}
\item[{\sphinxstylestrong{Return}}] \leavevmode

Whether the method could connect to ROS and CoppeliaSim 


\item[{\sphinxstylestrong{Parameters}}] \leavevmode\begin{itemize}
\item {} \sphinxcode{nh} - 
Nodehandle to that this instance uses to communicate with ROS

\end{itemize}

\end{description}


\end{fulllineitems}


\end{fulllineitems}

\end{quote}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}