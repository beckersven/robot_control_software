

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>agiprobot_measurement.sensor_model &mdash; Agiprobot Measurement 1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'1.0',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Agiprobot Measurement
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Explanation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Usage_Guide.html">Usage Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../view_planning_detailed.html">Path Planning Detailed</a></li>
</ul>
<p class="caption"><span class="caption-text">Components</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_trajectory_manager.html">Trajectory Manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_sensor_model.html">Sensor Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_view.html">View Point</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Agiprobot Measurement</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>agiprobot_measurement.sensor_model</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for agiprobot_measurement.sensor_model</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">agiprobot_measurement.viewpoint</span> <span class="k">import</span> <span class="n">ViewPoint</span>
<span class="kn">import</span> <span class="nn">trimesh</span>
<span class="kn">from</span> <span class="nn">imp</span> <span class="k">import</span> <span class="n">find_module</span>
<span class="kn">import</span> <span class="nn">array</span>

<div class="viewcode-block" id="SensorModel"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel">[docs]</a><span class="k">class</span> <span class="nc">SensorModel</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computional representation of an laser triangulation sensor under influence of uncertainty.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches geometric sensor parameters in order to build a uncertainty-based model of a laser triangulation sensor.</span>

<span class="sd">        :param parameter_map: Geometric sensor-parameters packed as a dictionary</span>
<span class="sd">        :type parameter_map: dict</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: NoneType</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get sensor specifications from parameter server</span>
        <span class="k">try</span><span class="p">:</span>   
            <span class="bp">self</span><span class="o">.</span><span class="n">optimal_standoff</span> <span class="o">=</span> <span class="n">parameter_map</span><span class="p">[</span><span class="s2">&quot;optimal_standoff_mm&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span> <span class="o">=</span> <span class="n">parameter_map</span><span class="p">[</span><span class="s2">&quot;minimum_standoff_mm&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span> <span class="o">=</span> <span class="n">parameter_map</span><span class="p">[</span><span class="s2">&quot;maximum_standoff_mm&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maximum_deviation_theta</span> <span class="o">=</span> <span class="n">parameter_map</span><span class="p">[</span><span class="s2">&quot;theta_max_rad&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maximum_deviation_psi</span> <span class="o">=</span> <span class="n">parameter_map</span><span class="p">[</span><span class="s2">&quot;psi_max_rad&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K_u</span> <span class="o">=</span> <span class="n">parameter_map</span><span class="p">[</span><span class="s2">&quot;K_u&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">parameter_map</span><span class="p">[</span><span class="s2">&quot;alpha_rad&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fan_angle</span> <span class="o">=</span> <span class="n">parameter_map</span><span class="p">[</span><span class="s2">&quot;fan_angle_rad&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Provided parameter-map for sensor-model incomplete: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>
        
        <span class="c1"># Calculate useful sensor features from the specifics (so that they must not be calculated every time)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_standoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laser_emission_perception_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_standoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="kc">None</span>
  
    
<div class="viewcode-block" id="SensorModel.get_median_deviation_angle"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel.get_median_deviation_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_median_deviation_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the smallest angle allowed for tilting (smallest of maximum deviations of theta and psi devided by 2).</span>

<span class="sd">        :returns: Smallest angle allowed for tilting</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_deviation_theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_deviation_psi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="SensorModel.evaluate_score"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel.evaluate_score">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">psi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a score of uncertainty :math:`\\in [0,1]` for the given z and psi (higher score means lower uncertainty). The score</span>
<span class="sd">        is linear affine in the uncertainty based on z and psi - It is 1 if the provided values match the best possible case (lowest</span>
<span class="sd">        possible uncertainty of the sensor model) and 0 when both values are right at the rejection limit (i.e. are equal to max_deviation_...):</span>
<span class="sd">        :math:`\\frac{u_{max} - u(z, \\psi)}{u_{max} - u_{min}}`</span>

<span class="sd">        :param z: z-coordinate of the point to evaluate in the laser_emitter_frame in mm</span>
<span class="sd">        :type z: float</span>
<span class="sd">        :param psi: Angle of the laser_emitter_frame&#39;s z-y-plane with the surface-triangle of the point to evaluate in rad</span>
<span class="sd">        :type psi: float</span>
<span class="sd">        :returns: Score :math:`\\in [0,1]` based on the parameters and the max_deviations of them</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_uncertainty</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_uncertainty</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">psi</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_uncertainty</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_min_uncertainty</span><span class="p">())</span></div>

<div class="viewcode-block" id="SensorModel.get_max_uncertainty"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel.get_max_uncertainty">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes maximum possible uncertainty of a measured point that is not rejected using geometric sensor parameters. </span>
<span class="sd">        The uncertainty-formula is evaluated at z- and psi-values that are at rejection-limits for a surface point, so that this value corresponds</span>
<span class="sd">        to the worst uncertainty assignable to a measurable point.</span>

<span class="sd">        :returns: Maximum possible uncertainty of a measurable point (= is within the max_deviation_...-range) in mm</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_deviation_psi</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SensorModel.get_min_uncertainty"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel.get_min_uncertainty">[docs]</a>    <span class="k">def</span> <span class="nf">get_min_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the minimum possible uncertainty using the geometric sensor parameters. It returns the uncertainty value assignable to</span>
<span class="sd">        a surface point which has been measured with optimal z- and psi-values, i.e. the best-case.</span>

<span class="sd">        :returns: Minimum possible uncertainty in mm</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="SensorModel.evaluate_uncertainty"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel.evaluate_uncertainty">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">psi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the uncertainty of a surface point with given z and psi using the specified geometric sensor parameters.</span>

<span class="sd">        :param z: z-coordinate of the point to evaluate in the laser_emitter_frame in mm</span>
<span class="sd">        :type z: float</span>
<span class="sd">        :param psi: Angle of the laser_emitter_frame&#39;s z-y-plane with the surface-triangle of the point to evaluate in rad</span>
<span class="sd">        :type psi: float</span>
<span class="sd">        :returns: Uncertainty based on the z, psi, and the geometric sensor parameters, or &#39;NaN&#39; if z and psi are invalid</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># See the corresponding bachelors thesis to understand the origin of this equation</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K_u</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_0</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">u</span></div>

<div class="viewcode-block" id="SensorModel.get_optimal_standoff"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel.get_optimal_standoff">[docs]</a>    <span class="k">def</span> <span class="nf">get_optimal_standoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the optimal standoff, i.e. required the .</span>
<span class="sd">        The returned optimal standoff is not equal to the standoff providing the lowest uncertainty, but in the center between the z-rejection-limits</span>
<span class="sd">        to allow maximum flexibility in surface height deviation when moving the sensor.</span>

<span class="sd">        :returns: z-coordinate in the laser_emitter_frame of an surface point for measurement in mm</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_standoff</span></div>

<div class="viewcode-block" id="SensorModel.set_processing_context"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel.set_processing_context">[docs]</a>    <span class="k">def</span> <span class="nf">set_processing_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">sampled_surface_points</span><span class="p">,</span> <span class="n">sampled_face_indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a context for metrological processing to the sensor model.</span>
<span class="sd">        This includes loading the target mesh into a ray-tracer as well as gaining awareness over the</span>
<span class="sd">        sampling results because they are directly used to assess a ViewPoint during process_viewpoint_metrologically().</span>
<span class="sd">        This method must be called before any metrological processing can be performed. A previously set</span>
<span class="sd">        context becomes overwritten completely by calling this method again.</span>

<span class="sd">        :param mesh: Mesh-object to load into the RayMeshIntersector</span>
<span class="sd">        :type mesh: trimesh.Trimesh</span>
<span class="sd">        :param sampled_surface_points: List of all sampled surface points that should be considered for the metrological processing</span>
<span class="sd">        :type sampled_surface_points: list[numpy.array]</span>
<span class="sd">        :param sampled_face_indices: List of face-indices, where each entry corresponds to the face of the sampled surface point at the same position</span>
<span class="sd">        :type sampled_face_indices: list[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;sampled_surface_points&quot;</span><span class="p">:</span>   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sampled_surface_points</span><span class="p">),</span>
            <span class="s2">&quot;sampled_face_indices&quot;</span><span class="p">:</span>     <span class="n">sampled_face_indices</span><span class="p">,</span>
            <span class="s2">&quot;face_normals&quot;</span><span class="p">:</span>             <span class="p">[</span><span class="n">face_normal</span> <span class="k">for</span> <span class="n">face_normal</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">face_normals</span><span class="p">],</span>
            <span class="s2">&quot;target_mesh&quot;</span><span class="p">:</span>              <span class="n">mesh</span>
        <span class="p">}</span>
    

        <span class="c1"># Load mesh into a RayMeshIntersector usable for ray-tracing tests and therefore metrological evaluation. </span>
        <span class="c1"># It tries to use the high-performing Intel(R) Embree raytracer (works with AMD-CPUs as well), but loads a slow default</span>
        <span class="c1"># raytracer if &#39;pyembree&#39;-python-package is not installed.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">find_module</span><span class="p">(</span><span class="s2">&quot;pyembree&quot;</span><span class="p">)</span>
            <span class="c1"># Scale to box is set to &#39;False&#39; as errors have been observed when &#39;True&#39; (obviously visible surface points</span>
            <span class="c1"># where evaluated as invisible during raytracing)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;ray_mesh_intersector&quot;</span><span class="p">:</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">ray</span><span class="o">.</span><span class="n">ray_pyembree</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">scale_to_box</span><span class="o">=</span><span class="kc">False</span><span class="p">)})</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;ray_mesh_intersector&quot;</span><span class="p">:</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">ray</span><span class="o">.</span><span class="n">ray_triangle</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">scale_to_box</span><span class="o">=</span><span class="kc">False</span><span class="p">)})</span></div>



<div class="viewcode-block" id="SensorModel.process_viewpoint_metrologically"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel.process_viewpoint_metrologically">[docs]</a>    <span class="k">def</span> <span class="nf">process_viewpoint_metrologically</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">viewpoint</span><span class="p">,</span> <span class="n">uncertainty_threshold</span><span class="p">,</span> <span class="n">maximum_deflection</span> <span class="o">=</span> <span class="mf">5e2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes all measurable surface-points by a viewpoint-object as well as uncertainties and where they are measurable on the viewpoint-measurement-trajectory.</span>
<span class="sd">        Requires context to be set via set_processing_context(...). Checks for every sampled surface point of the given context whether it is visible and calculates the</span>
<span class="sd">        uncertainty for it eventually. Also, the deflection of the laser_emitter_frame along the trajectory-line from the viewpoint-anchor pose is evaluated.</span>
<span class="sd">        </span>
<span class="sd">        :param viewpoint: ViewPoint with set viewpoint-anchor-pose</span>
<span class="sd">        :type viewpoint: ViewPoint</span>
<span class="sd">        :param uncertainty_threshold: Maximum permissible uncertainty of a measured surface point in mm</span>
<span class="sd">        :type uncertainty_threshold: float</span>
<span class="sd">        :param maximum_deflection: Maximum deflection of the trajectory to be considered for processing in mm, defaults to 5e2 </span>
<span class="sd">        :type maximum_deflection: float, optional</span>
<span class="sd">        :returns:   3 unpacked arrays of the same length in order:\n</span>
<span class="sd">                    - Indices of the measurable surface points in samples_surface_points_list\n</span>
<span class="sd">                    - Corresponding uncertainty-scores\n</span>
<span class="sd">                    - Metric distance in mm in trajectory-direction from the viewpoint-anchor where the corresponding surface point is measurable\n</span>
<span class="sd">        :rtype: array[int], array[float], array[float]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">viewpoint</span><span class="p">,</span> <span class="n">ViewPoint</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Set the context before performing metrological processing!&quot;</span><span class="p">)</span>    
        

        <span class="c1"># Only consider surface_points within the scanning_frustum to reduce processing overhead:</span>

        <span class="c1"># Make scan-frustum</span>
        <span class="n">scan_frustum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scanning_frustum</span><span class="p">(</span><span class="n">maximum_deflection</span><span class="p">)</span>
        <span class="c1"># Transform frustum so that it is aligned with the laser_emitter_frame at the viewpoint-anchor-pose</span>
        <span class="n">scan_frustum</span><span class="o">.</span><span class="n">apply_transform</span><span class="p">(</span><span class="n">viewpoint</span><span class="o">.</span><span class="n">get_orientation_matrix</span><span class="p">())</span>
        <span class="n">scan_frustum</span><span class="o">.</span><span class="n">apply_transform</span><span class="p">(</span><span class="n">viewpoint</span><span class="o">.</span><span class="n">get_anchor_position</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># Use RayMeshIntersector to identify the surface_points that are potentially measurable</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">find_module</span><span class="p">(</span><span class="s2">&quot;pyembree&quot;</span><span class="p">)</span>
            <span class="n">inliers</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">ray</span><span class="o">.</span><span class="n">ray_pyembree</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">scan_frustum</span><span class="p">,</span> <span class="n">scale_to_box</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;sampled_surface_points&quot;</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">inliers</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">ray</span><span class="o">.</span><span class="n">ray_triangle</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">scan_frustum</span><span class="p">,</span> <span class="n">scale_to_box</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;sampled_surface_points&quot;</span><span class="p">])</span>
        <span class="c1"># Extract the indices of the covered points in sampled_surface_points</span>
        <span class="n">inlier_indices</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inliers</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">inliers</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">inlier_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Get characteristic geometrical specifications of the viewpoint-measurement-trajectory (= unit-vectors of the sensor-frame)</span>
        <span class="n">trajectory_direction</span> <span class="o">=</span> <span class="n">viewpoint</span><span class="o">.</span><span class="n">get_orientation_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">sensor_direction</span> <span class="o">=</span> <span class="n">viewpoint</span><span class="o">.</span><span class="n">get_orientation_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">lateral_direction</span> <span class="o">=</span> <span class="n">viewpoint</span><span class="o">.</span><span class="n">get_orientation_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># For each inlier, prepare perform 2 ray-tests (one from the laser_emitter_frame to the inlier and one from the laser_detector_frame to the inlier)</span>
        <span class="n">ray_origins_emitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inlier_indices</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ray_directions_emitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inlier_indices</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ray_origins_detector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inlier_indices</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ray_directions_detector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inlier_indices</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">trajectory_line_arguments</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[])</span>  
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inlier_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inlier_indices</span><span class="p">):</span>
            <span class="c1"># t_0 = distance in trajectory_direction where the inlier becomes visible, i.e. the vector from inlier to trajectory becomes perpendicular to this direction</span>
            <span class="n">t_0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;sampled_surface_points&quot;</span><span class="p">][</span><span class="n">inlier_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">viewpoint</span><span class="o">.</span><span class="n">get_anchor_position</span><span class="p">())</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">trajectory_direction</span><span class="p">)</span>
            <span class="n">trajectory_line_arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_0</span><span class="p">)</span>
            <span class="n">ray_origins_emitter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_0</span> <span class="o">*</span> <span class="n">trajectory_direction</span> <span class="o">+</span> <span class="n">viewpoint</span><span class="o">.</span><span class="n">get_anchor_position</span><span class="p">()</span>
            <span class="n">ray_directions_emitter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;sampled_surface_points&quot;</span><span class="p">][</span><span class="n">inlier_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">ray_origins_emitter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Detector has a fixed offset on the viewpoint-measurement-trajectory in trajectory_direction</span>
            <span class="n">ray_origins_detector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_origins_emitter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">trajectory_direction</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_emission_perception_distance</span>
            <span class="n">ray_directions_detector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;sampled_surface_points&quot;</span><span class="p">][</span><span class="n">inlier_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">ray_origins_detector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Get the first intersections of the rays with the object mesh (only those are relevant for visibility concerns)</span>
        <span class="n">rt_emitter_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;ray_mesh_intersector&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">intersects_first</span><span class="p">(</span>
            <span class="n">ray_origins</span><span class="o">=</span><span class="n">ray_origins_emitter</span><span class="p">,</span>
            <span class="n">ray_directions</span><span class="o">=</span><span class="n">ray_directions_emitter</span>
            <span class="p">)</span>
        <span class="n">rt_detector_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;ray_mesh_intersector&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">intersects_first</span><span class="p">(</span>
            <span class="n">ray_origins</span><span class="o">=</span><span class="n">ray_origins_detector</span><span class="p">,</span>
            <span class="n">ray_directions</span><span class="o">=</span><span class="n">ray_directions_detector</span>
            <span class="p">)</span>

        <span class="n">measurable_surface_point_indices</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">uncertainties</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">trajectory_line_arguments_selected</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[])</span>

        <span class="c1"># Filter the inliers (each iteration represents the evaluation of one inlier as rt_..._results are sorted)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rt_emitter_face_id</span><span class="p">,</span> <span class="n">rt_detector_face_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rt_emitter_result</span><span class="p">,</span> <span class="n">rt_detector_result</span><span class="p">)):</span>
            <span class="c1"># Reject if the rays from the detector and emitter hit different surface-triangles or if the hit surface for a surface point does not match the corresponding sample_surface_index</span>
            <span class="k">if</span> <span class="n">rt_emitter_face_id</span> <span class="o">!=</span> <span class="n">rt_detector_face_id</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;sampled_face_indices&quot;</span><span class="p">][</span><span class="n">inlier_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">rt_detector_face_id</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Compute uncertainty-parameters z, psi, theta</span>
                <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">trajectory_direction</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;face_normals&quot;</span><span class="p">][</span><span class="n">rt_detector_face_id</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">sensor_direction</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;face_normals&quot;</span><span class="p">][</span><span class="n">rt_detector_face_id</span><span class="p">]))</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;face_normals&quot;</span><span class="p">][</span><span class="n">rt_detector_face_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ray_directions_emitter</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ray_directions_emitter</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sensor_direction</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="c1"># Wrapping into [-pi, pi]</span>
                <span class="k">if</span> <span class="n">theta</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">theta</span>
                <span class="k">elif</span> <span class="n">theta</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">theta</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">sensor_direction</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;sampled_surface_points&quot;</span><span class="p">][</span><span class="n">inlier_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">ray_origins_emitter</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># Only accept, if no violation of hard geometric limit</span>
                
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_deviation_psi</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_deviation_theta</span> <span class="ow">and</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span> <span class="ow">and</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_uncertainty</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sensor_direction</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;face_normals&quot;</span><span class="p">][</span><span class="n">rt_detector_face_id</span><span class="p">]))</span>
                    <span class="c1"># Only accept, if no violation of hard uncertainty threshold</span>
                    <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">uncertainty_threshold</span><span class="p">:</span>
                        <span class="n">uncertainties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                        <span class="n">measurable_surface_point_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inlier_indices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">trajectory_line_arguments_selected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajectory_line_arguments</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
       

        <span class="k">return</span> <span class="n">measurable_surface_point_indices</span><span class="p">,</span> <span class="n">uncertainties</span><span class="p">,</span> <span class="n">trajectory_line_arguments_selected</span></div>
        

<div class="viewcode-block" id="SensorModel.get_scanning_frustum"><a class="viewcode-back" href="../../agiprobot_measurement.html#agiprobot_measurement.sensor_model.SensorModel.get_scanning_frustum">[docs]</a>    <span class="k">def</span> <span class="nf">get_scanning_frustum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">half_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a trimesh-mesh object representing the &#39;frustum of measurability&#39; in the laser_emitter_frame. Points within this frustum have </span>
<span class="sd">        the potential to be measurable, but maximum_deviation_... may still reject points within this frustum. The frustum is constructed based on</span>
<span class="sd">        the laser-fan-angle and the allowed z-range and the idea that the trajectory is a straight line (it can be imagined as a cut-off &#39;Toblerone&#39;). </span>
<span class="sd">        So points lying wthin this frustum can be touched by the laser line AND can be mapped to the optical sensor.</span>

<span class="sd">        :param half_length: Length of the frustum perpendicular to the fan-plane in each direction of the laser_emitter_frame in mm</span>
<span class="sd">        :type half_length: float</span>
<span class="sd">        :returns: Scan frustum represting the volume of potentially measurable points</span>
<span class="sd">        :rtype: trimesh.Trimesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scanner_frustum_vertices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">half_length</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fan_angle</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span> <span class="n">half_length</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fan_angle</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span> <span class="n">half_length</span><span class="p">,</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fan_angle</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">],</span>
            <span class="p">[</span><span class="n">half_length</span><span class="p">,</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fan_angle</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_standoff</span><span class="p">],</span>
            <span class="p">[</span><span class="n">half_length</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fan_angle</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span> <span class="n">half_length</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fan_angle</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span> <span class="n">half_length</span><span class="p">,</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fan_angle</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span><span class="p">],</span>
            <span class="p">[</span><span class="n">half_length</span><span class="p">,</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fan_angle</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_standoff</span><span class="p">],</span>
        <span class="p">]</span>
        
        <span class="k">return</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">(</span><span class="n">scanner_frustum_vertices</span><span class="p">)</span><span class="o">.</span><span class="n">convex_hull</span></div></div>
    
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Sven Becker.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>